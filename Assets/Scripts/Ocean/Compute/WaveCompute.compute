#pragma kernel CSMain


RWTexture2D<float4> pastWave;
RWTexture2D<float4> currentWave;
RWTexture2D<float4> nextWave;
RWTexture2D<float4> obstaclesTex;

bool loop;

int2 resolution;
float elasticity;
bool useReflectiveBoundaryCondition;


[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	float nextWaveHeight;
    float v = (0.5f - 1.0f) / (0.5f + 1.0f);
		
    if (id.x == 0 && loop == false)
    {
		
		if (useReflectiveBoundaryCondition) {
			nextWaveHeight = 0;
		}
		else {
			nextWaveHeight = currentWave[int2(1,id.y)].x + v * (nextWave[int2(1,id.y)].x - currentWave[int2(0,id.y)].x);
		}
	}
    else if (id.x == resolution.x - 1 && loop == false)
    {
		if (useReflectiveBoundaryCondition) {
			nextWaveHeight = 0;
		}
		else {
			nextWaveHeight = currentWave[int2(resolution.x - 2,id.y)].x + v * (nextWave[int2(resolution.x - 2,id.y)].x - currentWave[int2(resolution.x - 1,id.y)].x);
		}
	}
    else if (id.y == 0 && loop == false)
    {
		if (useReflectiveBoundaryCondition) {
			nextWaveHeight = 0;
		}
        else
        {
            nextWaveHeight = currentWave[int2(id.x, 1)].x + v * (nextWave[int2(id.x, 1)].x - currentWave[int2(id.x, 0)].x);
        }
    }
    else if (id.y == resolution.y - 1 && loop == false)
    {
		if (useReflectiveBoundaryCondition) {
			nextWaveHeight = 0;
		}
		else {
			nextWaveHeight = currentWave[int2(id.x,resolution.y - 2)].x + v * (nextWave[int2(id.x,resolution.y - 2)].x - currentWave[int2(id.x,resolution.y - 1)].x);
		}
	}
	else
    {
        float n00 = currentWave[id.xy].x;
        float n00Past = pastWave[id.xy].x;
        float n10 = (id.x != resolution.x - 1) ? currentWave[id.xy + int2(1, 0)].x : currentWave[int2(0, id.y)].x;
        float n01 = (id.y != resolution.y - 1) ? currentWave[id.xy + int2(0, 1)].x : currentWave[int2(id.x, 0)].x;
        float nm10 = (id.x != 0) ? currentWave[id.xy - int2(1, 0)].x : currentWave[int2(resolution.x - 1, id.y)].x;
        float n0m1 = (id.y != 0) ? currentWave[id.xy - int2(0, 1)].x : currentWave[int2(id.x, resolution.y - 1)].x;

        nextWaveHeight = 2.0f * n00 - n00Past + 0.25 * (n0m1 + n01 + nm10 + n10 - 4.0f * n00);
        nextWaveHeight *= elasticity;
    }

    if (obstaclesTex[id.xy].x == 1)
    {
        nextWaveHeight = 0;
    }
    else if (obstaclesTex[id.xy].y == 1)
    {
        nextWaveHeight = -0.5;
    }
    else if (obstaclesTex[id.xy].z == 1)
    {
        nextWaveHeight = -0.5;
    }

	nextWave[id.xy] = float4(nextWaveHeight, nextWaveHeight, nextWaveHeight, 1);
}
